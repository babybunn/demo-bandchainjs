{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst constant_1 = require(\"./constant\");\n\nconst error_1 = require(\"./error\");\n\nconst utils_1 = require(\"./utils\");\n\nconst tx_pb_1 = require(\"../proto/cosmos/tx/v1beta1/tx_pb\");\n\nconst signing_pb_1 = require(\"../proto/cosmos/tx/signing/v1beta1/signing_pb\");\n\nconst any_pb_1 = require(\"google-protobuf/google/protobuf/any_pb\");\n\nconst tx_pb_2 = require(\"../proto/cosmos/tx/v1beta1/tx_pb\");\n\nclass Transaction {\n  constructor() {\n    this.msgs = [];\n    this.fee = new tx_pb_2.Fee();\n    this.memo = '';\n  }\n\n  withMessages(...msg) {\n    this.msgs.push(...msg);\n    return this;\n  }\n\n  withSender(client, sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.msgs.length === 0) {\n        throw new error_1.EmptyMsgError('Message is empty, please use withMessages at least 1 message.');\n      }\n\n      let account = yield client.getAccount(sender);\n\n      if (!account) {\n        throw new error_1.NotFoundError(`Account doesn't exist.`);\n      }\n\n      this.accountNum = account.accountNumber;\n      this.sequence = account.sequence;\n      return this;\n    });\n  }\n\n  withAccountNum(accountNum) {\n    if (!Number.isInteger(accountNum)) {\n      throw new error_1.NotIntegerError('accountNum is not an integer');\n    }\n\n    this.accountNum = accountNum;\n    return this;\n  }\n\n  withSequence(sequence) {\n    if (!Number.isInteger(sequence)) {\n      throw new error_1.NotIntegerError('sequence is not an integer');\n    }\n\n    this.sequence = sequence;\n    return this;\n  }\n\n  withChainId(chainId) {\n    this.chainId = chainId;\n    return this;\n  }\n\n  withFee(fee) {\n    this.fee = fee;\n    return this;\n  }\n\n  withMemo(memo) {\n    if (memo.length > constant_1.MAX_MEMO_CHARACTERS) {\n      throw new error_1.ValueTooLargeError('memo is too large.');\n    }\n\n    this.memo = memo;\n    return this;\n  }\n\n  getInfo(publicKey, signMode) {\n    let txBody = new tx_pb_1.TxBody();\n    txBody.setMessagesList(this.msgs.map(msg => msg.toAny()));\n    txBody.setMemo(this.memo);\n    let txBodyBytes = txBody.serializeBinary();\n    let modeInfo = new tx_pb_1.ModeInfo();\n    let modeSingle = new tx_pb_1.ModeInfo.Single();\n    modeSingle.setMode(signMode);\n    modeInfo.setSingle(modeSingle);\n    let publicKeyAny = new any_pb_1.Any();\n    publicKeyAny.pack(publicKey.toPubkeyProto().serializeBinary(), 'cosmos.crypto.secp256k1.PubKey', '/');\n    let signerInfo = new tx_pb_1.SignerInfo();\n    signerInfo.setModeInfo(modeInfo);\n    signerInfo.setSequence(this.sequence);\n    signerInfo.setPublicKey(publicKeyAny);\n    let authInfo = new tx_pb_1.AuthInfo();\n    authInfo.addSignerInfos(signerInfo);\n    authInfo.setFee(this.fee);\n    let authInfoBytes = authInfo.serializeBinary();\n    return [txBodyBytes, authInfoBytes];\n  }\n\n  getSignDoc(publicKey) {\n    if (this.msgs.length === 0) {\n      throw new error_1.EmptyMsgError('message is empty');\n    }\n\n    if (this.accountNum === undefined) {\n      throw new error_1.UndefinedError('accountNum should be defined');\n    }\n\n    if (this.sequence === undefined) {\n      throw new error_1.UndefinedError('sequence should be defined');\n    }\n\n    if (this.chainId === undefined) {\n      throw new error_1.UndefinedError('chainId should be defined');\n    }\n\n    const [txBodyBytes, authInfoBytes] = this.getInfo(publicKey, signing_pb_1.SignMode.SIGN_MODE_DIRECT);\n    let signDoc = new tx_pb_1.SignDoc();\n    signDoc.setBodyBytes(txBodyBytes);\n    signDoc.setAuthInfoBytes(authInfoBytes);\n    signDoc.setChainId(this.chainId);\n    signDoc.setAccountNumber(this.accountNum);\n    return signDoc.serializeBinary();\n  }\n\n  getTxData(signature, publicKey, signMode = signing_pb_1.SignMode.SIGN_MODE_DIRECT) {\n    const [txBodyBytes, authInfoBytes] = this.getInfo(publicKey, signMode);\n    let txRaw = new tx_pb_1.TxRaw();\n    txRaw.setBodyBytes(txBodyBytes);\n    txRaw.setAuthInfoBytes(authInfoBytes);\n    txRaw.addSignatures(signature);\n    return txRaw.serializeBinary();\n  }\n\n  getSignMessage() {\n    return Buffer.from(utils_1.sortAndStringify({\n      account_number: this.accountNum.toString(),\n      chain_id: this.chainId,\n      fee: {\n        amount: this.fee.getAmountList().map(coin => coin.toObject()),\n        gas: this.fee.getGasLimit().toString()\n      },\n      memo: this.memo,\n      msgs: this.msgs.map(msg => msg.toJSON()),\n      sequence: this.sequence.toString()\n    }));\n  }\n\n}\n\nexports.default = Transaction;","map":{"version":3,"sources":["/Users/pangp/Band/demo-bandchainjs/node_modules/@bandprotocol/bandchain.js/lib/transaction.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","constant_1","require","error_1","utils_1","tx_pb_1","signing_pb_1","any_pb_1","tx_pb_2","Transaction","constructor","msgs","fee","Fee","memo","withMessages","msg","push","withSender","client","sender","length","EmptyMsgError","account","getAccount","NotFoundError","accountNum","accountNumber","sequence","withAccountNum","Number","isInteger","NotIntegerError","withSequence","withChainId","chainId","withFee","withMemo","MAX_MEMO_CHARACTERS","ValueTooLargeError","getInfo","publicKey","signMode","txBody","TxBody","setMessagesList","map","toAny","setMemo","txBodyBytes","serializeBinary","modeInfo","ModeInfo","modeSingle","Single","setMode","setSingle","publicKeyAny","Any","pack","toPubkeyProto","signerInfo","SignerInfo","setModeInfo","setSequence","setPublicKey","authInfo","AuthInfo","addSignerInfos","setFee","authInfoBytes","getSignDoc","undefined","UndefinedError","SignMode","SIGN_MODE_DIRECT","signDoc","SignDoc","setBodyBytes","setAuthInfoBytes","setChainId","setAccountNumber","getTxData","signature","txRaw","TxRaw","addSignatures","getSignMessage","Buffer","from","sortAndStringify","account_number","toString","chain_id","amount","getAmountList","coin","toObject","gas","getGasLimit","toJSON","default"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constant_1 = require(\"./constant\");\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\nconst tx_pb_1 = require(\"../proto/cosmos/tx/v1beta1/tx_pb\");\nconst signing_pb_1 = require(\"../proto/cosmos/tx/signing/v1beta1/signing_pb\");\nconst any_pb_1 = require(\"google-protobuf/google/protobuf/any_pb\");\nconst tx_pb_2 = require(\"../proto/cosmos/tx/v1beta1/tx_pb\");\nclass Transaction {\n    constructor() {\n        this.msgs = [];\n        this.fee = new tx_pb_2.Fee();\n        this.memo = '';\n    }\n    withMessages(...msg) {\n        this.msgs.push(...msg);\n        return this;\n    }\n    withSender(client, sender) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.msgs.length === 0) {\n                throw new error_1.EmptyMsgError('Message is empty, please use withMessages at least 1 message.');\n            }\n            let account = yield client.getAccount(sender);\n            if (!account) {\n                throw new error_1.NotFoundError(`Account doesn't exist.`);\n            }\n            this.accountNum = account.accountNumber;\n            this.sequence = account.sequence;\n            return this;\n        });\n    }\n    withAccountNum(accountNum) {\n        if (!Number.isInteger(accountNum)) {\n            throw new error_1.NotIntegerError('accountNum is not an integer');\n        }\n        this.accountNum = accountNum;\n        return this;\n    }\n    withSequence(sequence) {\n        if (!Number.isInteger(sequence)) {\n            throw new error_1.NotIntegerError('sequence is not an integer');\n        }\n        this.sequence = sequence;\n        return this;\n    }\n    withChainId(chainId) {\n        this.chainId = chainId;\n        return this;\n    }\n    withFee(fee) {\n        this.fee = fee;\n        return this;\n    }\n    withMemo(memo) {\n        if (memo.length > constant_1.MAX_MEMO_CHARACTERS) {\n            throw new error_1.ValueTooLargeError('memo is too large.');\n        }\n        this.memo = memo;\n        return this;\n    }\n    getInfo(publicKey, signMode) {\n        let txBody = new tx_pb_1.TxBody();\n        txBody.setMessagesList(this.msgs.map((msg) => msg.toAny()));\n        txBody.setMemo(this.memo);\n        let txBodyBytes = txBody.serializeBinary();\n        let modeInfo = new tx_pb_1.ModeInfo();\n        let modeSingle = new tx_pb_1.ModeInfo.Single();\n        modeSingle.setMode(signMode);\n        modeInfo.setSingle(modeSingle);\n        let publicKeyAny = new any_pb_1.Any();\n        publicKeyAny.pack(publicKey.toPubkeyProto().serializeBinary(), 'cosmos.crypto.secp256k1.PubKey', '/');\n        let signerInfo = new tx_pb_1.SignerInfo();\n        signerInfo.setModeInfo(modeInfo);\n        signerInfo.setSequence(this.sequence);\n        signerInfo.setPublicKey(publicKeyAny);\n        let authInfo = new tx_pb_1.AuthInfo();\n        authInfo.addSignerInfos(signerInfo);\n        authInfo.setFee(this.fee);\n        let authInfoBytes = authInfo.serializeBinary();\n        return [txBodyBytes, authInfoBytes];\n    }\n    getSignDoc(publicKey) {\n        if (this.msgs.length === 0) {\n            throw new error_1.EmptyMsgError('message is empty');\n        }\n        if (this.accountNum === undefined) {\n            throw new error_1.UndefinedError('accountNum should be defined');\n        }\n        if (this.sequence === undefined) {\n            throw new error_1.UndefinedError('sequence should be defined');\n        }\n        if (this.chainId === undefined) {\n            throw new error_1.UndefinedError('chainId should be defined');\n        }\n        const [txBodyBytes, authInfoBytes] = this.getInfo(publicKey, signing_pb_1.SignMode.SIGN_MODE_DIRECT);\n        let signDoc = new tx_pb_1.SignDoc();\n        signDoc.setBodyBytes(txBodyBytes);\n        signDoc.setAuthInfoBytes(authInfoBytes);\n        signDoc.setChainId(this.chainId);\n        signDoc.setAccountNumber(this.accountNum);\n        return signDoc.serializeBinary();\n    }\n    getTxData(signature, publicKey, signMode = signing_pb_1.SignMode.SIGN_MODE_DIRECT) {\n        const [txBodyBytes, authInfoBytes] = this.getInfo(publicKey, signMode);\n        let txRaw = new tx_pb_1.TxRaw();\n        txRaw.setBodyBytes(txBodyBytes);\n        txRaw.setAuthInfoBytes(authInfoBytes);\n        txRaw.addSignatures(signature);\n        return txRaw.serializeBinary();\n    }\n    getSignMessage() {\n        return Buffer.from(utils_1.sortAndStringify({\n            account_number: this.accountNum.toString(),\n            chain_id: this.chainId,\n            fee: {\n                amount: this.fee.getAmountList().map(coin => coin.toObject()),\n                gas: this.fee.getGasLimit().toString(),\n            },\n            memo: this.memo,\n            msgs: this.msgs.map((msg) => msg.toJSON()),\n            sequence: this.sequence.toString(),\n        }));\n    }\n}\nexports.default = Transaction;\n"]},"metadata":{},"sourceType":"script"}