{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = exports.PublicKey = exports.PrivateKey = void 0;\n\nconst bip39 = __importStar(require(\"bip39\"));\n\nconst bip32 = __importStar(require(\"bip32\"));\n\nconst bech32 = __importStar(require(\"bech32\"));\n\nconst secp256k1_1 = __importDefault(require(\"secp256k1\"));\n\nconst crypto_1 = __importDefault(require(\"crypto\"));\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nconst error_1 = require(\"./error\");\n\nconst keys_pb_1 = require(\"../proto/cosmos/crypto/secp256k1/keys_pb\");\n\nconst BECH32_PUBKEY_ACC_PREFIX = 'bandpub';\nconst BECH32_PUBKEY_VAL_PREFIX = 'bandvaloperpub';\nconst BECH32_PUBKEY_CONS_PREFIX = 'bandvalconspub';\nconst BECH32_ADDR_ACC_PREFIX = 'band';\nconst BECH32_ADDR_VAL_PREFIX = 'bandvaloper';\nconst BECH32_ADDR_CONS_PREFIX = 'bandvalcons';\nconst DEFAULT_DERIVATION_PATH = \"m/44'/494'/0'/0/0\";\n\nclass PrivateKey {\n  constructor(signingKey) {\n    this.signingKey = signingKey;\n  }\n\n  static generate(path = DEFAULT_DERIVATION_PATH) {\n    const phrase = bip39.generateMnemonic(256);\n    return [phrase, this.fromMnemonic(phrase, path)];\n  }\n\n  static fromMnemonic(words, path = DEFAULT_DERIVATION_PATH) {\n    const seed = bip39.mnemonicToSeedSync(words);\n    const node = bip32.fromSeed(seed);\n    const child = node.derivePath(path);\n    if (!child.privateKey) throw new error_1.CreateError('Cannot create private key');\n    const ecpair = bitcoinjs_lib_1.ECPair.fromPrivateKey(child.privateKey, {\n      compressed: false\n    });\n    if (!ecpair.privateKey) throw new error_1.CreateError('Cannot create private key');\n    return new PrivateKey(ecpair.privateKey);\n  }\n\n  static fromHex(priv) {\n    return new PrivateKey(Buffer.from(priv, 'hex'));\n  }\n\n  toHex() {\n    return this.signingKey.toString('hex');\n  }\n\n  toPubkey() {\n    const pubKeyByte = secp256k1_1.default.publicKeyCreate(this.signingKey);\n    return PublicKey.fromHex(Buffer.from(pubKeyByte).toString('hex'));\n  }\n\n  sign(msg) {\n    const hash = crypto_1.default.createHash('sha256').update(msg).digest('hex');\n    const buf = Buffer.from(hash, 'hex');\n    const {\n      signature\n    } = secp256k1_1.default.ecdsaSign(buf, this.signingKey);\n    return Buffer.from(signature);\n  }\n\n}\n\nexports.PrivateKey = PrivateKey;\n\nclass PublicKey {\n  constructor(verifyKey) {\n    this.verifyKey = verifyKey;\n  }\n\n  static fromBech32(bech, _prefix) {\n    const {\n      prefix,\n      words\n    } = bech32.decode(bech);\n    if (prefix != _prefix) throw new error_1.ValueError('Invalid bech32 prefix');\n    if (words.length === 0) throw new error_1.DecodeError('Cannot decode bech32');\n    return new PublicKey(Buffer.from(bech32.fromWords(words).slice(5)));\n  }\n\n  static fromHex(pub) {\n    return new PublicKey(Buffer.from(pub, 'hex'));\n  }\n\n  static fromAccBech32(bech) {\n    return this.fromBech32(bech, BECH32_PUBKEY_ACC_PREFIX);\n  }\n\n  static fromValBech32(bech) {\n    return this.fromBech32(bech, BECH32_PUBKEY_VAL_PREFIX);\n  }\n\n  static fromConsBech32(bech) {\n    return this.fromBech32(bech, BECH32_PUBKEY_CONS_PREFIX);\n  }\n\n  toBech32(prefix) {\n    const hex = Buffer.concat([Buffer.from('eb5ae98721', 'hex'), this.verifyKey]);\n    const words = bech32.toWords(Buffer.from(hex));\n    if (words.length === 0) throw new error_1.UnsuccessfulCallError('Unsuccessful bech32.toWords call');\n    return bech32.encode(prefix, words);\n  }\n\n  toPubkeyProto() {\n    const publicKeyProto = new keys_pb_1.PubKey();\n    publicKeyProto.setKey(this.verifyKey);\n    return publicKeyProto;\n  }\n\n  toAccBech32() {\n    return this.toBech32(BECH32_PUBKEY_ACC_PREFIX);\n  }\n\n  toValBech32() {\n    return this.toBech32(BECH32_PUBKEY_VAL_PREFIX);\n  }\n\n  toConsBech32() {\n    return this.toBech32(BECH32_PUBKEY_CONS_PREFIX);\n  }\n\n  toHex() {\n    return this.verifyKey.toString('hex');\n  }\n\n  toAddress() {\n    const hash = crypto_1.default.createHash('sha256').update(this.verifyKey).digest();\n    return Address.fromHex(crypto_1.default.createHash('ripemd160').update(hash).digest('hex'));\n  }\n\n  verify(msg, sig) {\n    const hash = crypto_1.default.createHash('sha256').update(msg).digest('hex');\n    const buf = Buffer.from(hash, 'hex');\n    return secp256k1_1.default.ecdsaVerify(sig, buf, this.verifyKey);\n  }\n\n}\n\nexports.PublicKey = PublicKey;\n\nclass Address {\n  constructor(addr) {\n    this.addr = addr;\n  }\n\n  static fromBech32(bech, _prefix) {\n    const {\n      prefix,\n      words\n    } = bech32.decode(bech);\n    if (prefix != _prefix) throw new error_1.ValueError('Invalid bech32 prefix');\n    if (words.length === 0) throw new error_1.DecodeError('Cannot decode bech32');\n    return new Address(Buffer.from(bech32.fromWords(words)));\n  }\n\n  static fromHex(hex) {\n    return new Address(Buffer.from(hex, 'hex'));\n  }\n\n  static fromAccBech32(bech) {\n    return this.fromBech32(bech, BECH32_ADDR_ACC_PREFIX);\n  }\n\n  static fromValBech32(bech) {\n    return this.fromBech32(bech, BECH32_ADDR_VAL_PREFIX);\n  }\n\n  static fromConsBech32(bech) {\n    return this.fromBech32(bech, BECH32_ADDR_CONS_PREFIX);\n  }\n\n  toBech32(prefix) {\n    const words = bech32.toWords(this.addr);\n    if (words.length === 0) throw new error_1.UnsuccessfulCallError('Unsuccessful bech32.toWords call');\n    return bech32.encode(prefix, words);\n  }\n\n  toAccBech32() {\n    return this.toBech32(BECH32_ADDR_ACC_PREFIX);\n  }\n\n  toValBech32() {\n    return this.toBech32(BECH32_ADDR_VAL_PREFIX);\n  }\n\n  toConsBech32() {\n    return this.toBech32(BECH32_ADDR_CONS_PREFIX);\n  }\n\n  toHex() {\n    return this.addr.toString('hex');\n  }\n\n}\n\nexports.Address = Address;","map":{"version":3,"sources":["/Users/pangp/Band/demo-bandchainjs/client/node_modules/@bandprotocol/bandchain.js/lib/wallet.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","__importDefault","exports","Address","PublicKey","PrivateKey","bip39","require","bip32","bech32","secp256k1_1","crypto_1","bitcoinjs_lib_1","error_1","keys_pb_1","BECH32_PUBKEY_ACC_PREFIX","BECH32_PUBKEY_VAL_PREFIX","BECH32_PUBKEY_CONS_PREFIX","BECH32_ADDR_ACC_PREFIX","BECH32_ADDR_VAL_PREFIX","BECH32_ADDR_CONS_PREFIX","DEFAULT_DERIVATION_PATH","constructor","signingKey","generate","path","phrase","generateMnemonic","fromMnemonic","words","seed","mnemonicToSeedSync","node","fromSeed","child","derivePath","privateKey","CreateError","ecpair","ECPair","fromPrivateKey","compressed","fromHex","priv","Buffer","from","toHex","toString","toPubkey","pubKeyByte","default","publicKeyCreate","sign","msg","hash","createHash","update","digest","buf","signature","ecdsaSign","verifyKey","fromBech32","bech","_prefix","prefix","decode","ValueError","length","DecodeError","fromWords","slice","pub","fromAccBech32","fromValBech32","fromConsBech32","toBech32","hex","concat","toWords","UnsuccessfulCallError","encode","toPubkeyProto","publicKeyProto","PubKey","setKey","toAccBech32","toValBech32","toConsBech32","toAddress","verify","sig","ecdsaVerify","addr"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Address = exports.PublicKey = exports.PrivateKey = void 0;\nconst bip39 = __importStar(require(\"bip39\"));\nconst bip32 = __importStar(require(\"bip32\"));\nconst bech32 = __importStar(require(\"bech32\"));\nconst secp256k1_1 = __importDefault(require(\"secp256k1\"));\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\nconst error_1 = require(\"./error\");\nconst keys_pb_1 = require(\"../proto/cosmos/crypto/secp256k1/keys_pb\");\nconst BECH32_PUBKEY_ACC_PREFIX = 'bandpub';\nconst BECH32_PUBKEY_VAL_PREFIX = 'bandvaloperpub';\nconst BECH32_PUBKEY_CONS_PREFIX = 'bandvalconspub';\nconst BECH32_ADDR_ACC_PREFIX = 'band';\nconst BECH32_ADDR_VAL_PREFIX = 'bandvaloper';\nconst BECH32_ADDR_CONS_PREFIX = 'bandvalcons';\nconst DEFAULT_DERIVATION_PATH = \"m/44'/494'/0'/0/0\";\nclass PrivateKey {\n    constructor(signingKey) {\n        this.signingKey = signingKey;\n    }\n    static generate(path = DEFAULT_DERIVATION_PATH) {\n        const phrase = bip39.generateMnemonic(256);\n        return [phrase, this.fromMnemonic(phrase, path)];\n    }\n    static fromMnemonic(words, path = DEFAULT_DERIVATION_PATH) {\n        const seed = bip39.mnemonicToSeedSync(words);\n        const node = bip32.fromSeed(seed);\n        const child = node.derivePath(path);\n        if (!child.privateKey)\n            throw new error_1.CreateError('Cannot create private key');\n        const ecpair = bitcoinjs_lib_1.ECPair.fromPrivateKey(child.privateKey, {\n            compressed: false,\n        });\n        if (!ecpair.privateKey)\n            throw new error_1.CreateError('Cannot create private key');\n        return new PrivateKey(ecpair.privateKey);\n    }\n    static fromHex(priv) {\n        return new PrivateKey(Buffer.from(priv, 'hex'));\n    }\n    toHex() {\n        return this.signingKey.toString('hex');\n    }\n    toPubkey() {\n        const pubKeyByte = secp256k1_1.default.publicKeyCreate(this.signingKey);\n        return PublicKey.fromHex(Buffer.from(pubKeyByte).toString('hex'));\n    }\n    sign(msg) {\n        const hash = crypto_1.default.createHash('sha256').update(msg).digest('hex');\n        const buf = Buffer.from(hash, 'hex');\n        const { signature } = secp256k1_1.default.ecdsaSign(buf, this.signingKey);\n        return Buffer.from(signature);\n    }\n}\nexports.PrivateKey = PrivateKey;\nclass PublicKey {\n    constructor(verifyKey) {\n        this.verifyKey = verifyKey;\n    }\n    static fromBech32(bech, _prefix) {\n        const { prefix, words } = bech32.decode(bech);\n        if (prefix != _prefix)\n            throw new error_1.ValueError('Invalid bech32 prefix');\n        if (words.length === 0)\n            throw new error_1.DecodeError('Cannot decode bech32');\n        return new PublicKey(Buffer.from(bech32.fromWords(words).slice(5)));\n    }\n    static fromHex(pub) {\n        return new PublicKey(Buffer.from(pub, 'hex'));\n    }\n    static fromAccBech32(bech) {\n        return this.fromBech32(bech, BECH32_PUBKEY_ACC_PREFIX);\n    }\n    static fromValBech32(bech) {\n        return this.fromBech32(bech, BECH32_PUBKEY_VAL_PREFIX);\n    }\n    static fromConsBech32(bech) {\n        return this.fromBech32(bech, BECH32_PUBKEY_CONS_PREFIX);\n    }\n    toBech32(prefix) {\n        const hex = Buffer.concat([\n            Buffer.from('eb5ae98721', 'hex'),\n            this.verifyKey,\n        ]);\n        const words = bech32.toWords(Buffer.from(hex));\n        if (words.length === 0)\n            throw new error_1.UnsuccessfulCallError('Unsuccessful bech32.toWords call');\n        return bech32.encode(prefix, words);\n    }\n    toPubkeyProto() {\n        const publicKeyProto = new keys_pb_1.PubKey();\n        publicKeyProto.setKey(this.verifyKey);\n        return publicKeyProto;\n    }\n    toAccBech32() {\n        return this.toBech32(BECH32_PUBKEY_ACC_PREFIX);\n    }\n    toValBech32() {\n        return this.toBech32(BECH32_PUBKEY_VAL_PREFIX);\n    }\n    toConsBech32() {\n        return this.toBech32(BECH32_PUBKEY_CONS_PREFIX);\n    }\n    toHex() {\n        return this.verifyKey.toString('hex');\n    }\n    toAddress() {\n        const hash = crypto_1.default.createHash('sha256').update(this.verifyKey).digest();\n        return Address.fromHex(crypto_1.default.createHash('ripemd160').update(hash).digest('hex'));\n    }\n    verify(msg, sig) {\n        const hash = crypto_1.default.createHash('sha256').update(msg).digest('hex');\n        const buf = Buffer.from(hash, 'hex');\n        return secp256k1_1.default.ecdsaVerify(sig, buf, this.verifyKey);\n    }\n}\nexports.PublicKey = PublicKey;\nclass Address {\n    constructor(addr) {\n        this.addr = addr;\n    }\n    static fromBech32(bech, _prefix) {\n        const { prefix, words } = bech32.decode(bech);\n        if (prefix != _prefix)\n            throw new error_1.ValueError('Invalid bech32 prefix');\n        if (words.length === 0)\n            throw new error_1.DecodeError('Cannot decode bech32');\n        return new Address(Buffer.from(bech32.fromWords(words)));\n    }\n    static fromHex(hex) {\n        return new Address(Buffer.from(hex, 'hex'));\n    }\n    static fromAccBech32(bech) {\n        return this.fromBech32(bech, BECH32_ADDR_ACC_PREFIX);\n    }\n    static fromValBech32(bech) {\n        return this.fromBech32(bech, BECH32_ADDR_VAL_PREFIX);\n    }\n    static fromConsBech32(bech) {\n        return this.fromBech32(bech, BECH32_ADDR_CONS_PREFIX);\n    }\n    toBech32(prefix) {\n        const words = bech32.toWords(this.addr);\n        if (words.length === 0)\n            throw new error_1.UnsuccessfulCallError('Unsuccessful bech32.toWords call');\n        return bech32.encode(prefix, words);\n    }\n    toAccBech32() {\n        return this.toBech32(BECH32_ADDR_ACC_PREFIX);\n    }\n    toValBech32() {\n        return this.toBech32(BECH32_ADDR_VAL_PREFIX);\n    }\n    toConsBech32() {\n        return this.toBech32(BECH32_ADDR_CONS_PREFIX);\n    }\n    toHex() {\n        return this.addr.toString('hex');\n    }\n}\nexports.Address = Address;\n"]},"metadata":{},"sourceType":"script"}